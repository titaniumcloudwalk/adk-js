/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {Content, createPartFromText, Modality} from '@google/genai';
import {trace} from '@opentelemetry/api';

import {ActiveStreamingTool} from '../agents/active_streaming_tool.js';
import {BaseAgent} from '../agents/base_agent.js';
import {InvocationContext, newInvocationContextId} from '../agents/invocation_context.js';
import {ReadonlyContext} from '../agents/readonly_context.js';
import {LiveRequestQueue} from '../agents/live_request_queue.js';
import {LlmAgent} from '../agents/llm_agent.js';
import {FunctionTool} from '../tools/function_tool.js';
import {createRunConfig, RunConfig} from '../agents/run_config.js';
import {BaseArtifactService} from '../artifacts/base_artifact_service.js';
import {BaseCredentialService} from '../auth/credential_service/base_credential_service.js';
import {BuiltInCodeExecutor} from '../code_executors/built_in_code_executor.js';
import {createEvent, Event, getFunctionCalls} from '../events/event.js';
import {createEventActions} from '../events/event_actions.js';
import {BaseMemoryService} from '../memory/base_memory_service.js';
import {BasePlugin} from '../plugins/base_plugin.js';
import {PluginManager} from '../plugins/plugin_manager.js';
import {BaseSessionService} from '../sessions/base_session_service.js';
import {Session} from '../sessions/session.js';
import {logger} from '../utils/logger.js';
import {isGemini2OrAbove} from '../utils/model_name.js';

interface RunnerInput {
  appName: string;
  agent: BaseAgent;
  plugins?: BasePlugin[];
  artifactService?: BaseArtifactService;
  sessionService: BaseSessionService;
  memoryService?: BaseMemoryService;
  credentialService?: BaseCredentialService;
  /**
   * Whether to automatically create a session when not found. Defaults to
   * false. If false, a missing session raises an error with a helpful message.
   */
  autoCreateSession?: boolean;
}

export class Runner {
  readonly appName: string;
  readonly agent: BaseAgent;
  readonly pluginManager: PluginManager;
  readonly artifactService?: BaseArtifactService;
  readonly sessionService: BaseSessionService;
  readonly memoryService?: BaseMemoryService;
  readonly credentialService?: BaseCredentialService;
  /**
   * Whether to automatically create a session when not found. Defaults to
   * false. If false, a missing session raises an error with a helpful message.
   */
  readonly autoCreateSession: boolean;

  constructor(input: RunnerInput) {
    this.appName = input.appName;
    this.agent = input.agent;
    this.pluginManager = new PluginManager(input.plugins ?? []);
    this.artifactService = input.artifactService;
    this.sessionService = input.sessionService;
    this.memoryService = input.memoryService;
    this.credentialService = input.credentialService;
    this.autoCreateSession = input.autoCreateSession ?? false;
  }

  /**
   * Gets the session or creates it if auto-creation is enabled.
   *
   * This helper first attempts to retrieve the session. If not found and
   * autoCreateSession is true, it creates a new session with the provided
   * identifiers. Otherwise, it throws an Error with a helpful message.
   *
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @returns The existing or newly created Session.
   * @throws Error if the session is not found and autoCreateSession is false.
   */
  private async getOrCreateSession({
    userId,
    sessionId,
  }: {
    userId: string;
    sessionId: string;
  }): Promise<Session> {
    let session = await this.sessionService.getSession({
      appName: this.appName,
      userId,
      sessionId,
    });

    if (!session) {
      if (this.autoCreateSession) {
        session = await this.sessionService.createSession({
          appName: this.appName,
          userId,
          sessionId,
        });
      } else {
        if (!this.appName) {
          throw new Error(
            `Session lookup failed: appName must be provided in runner constructor`
          );
        }
        throw new Error(
          `Session not found: ${sessionId}. To automatically create a session ` +
            `when missing, set autoCreateSession=true when constructing the runner.`
        );
      }
    }

    return session;
  }

  /**
   * Runs the agent with the given message, and returns an async generator of
   * events.
   *
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @param newMessage A new message to append to the session.
   * @param stateDelta An optional state delta to apply to the session.
   * @param runConfig The run config for the agent.
   * @yields The events generated by the agent.
   */
  // TODO - b/425992518: user, sessionId, and runConfig can be internalized.
  async * runAsync({
    userId,
    sessionId,
    newMessage,
    stateDelta,
    runConfig,
  }: {
    userId: string; sessionId: string; newMessage: Content;
    stateDelta?: Record<string, any>;
    runConfig?: RunConfig;
  }): AsyncGenerator<Event, void, undefined> {
    runConfig = createRunConfig(runConfig);
    // =========================================================================
    // Setup the session and invocation context
    // =========================================================================
    const span = trace.getTracer('gcp.vertex.agent').startSpan('invocation');
    try {
      const session = await this.getOrCreateSession({userId, sessionId});

      if (runConfig.supportCfc && this.agent instanceof LlmAgent) {
        const modelName = this.agent.canonicalModel.model;
        if (!isGemini2OrAbove(modelName)) {
          throw new Error(`CFC is not supported for model: ${
              modelName} in agent: ${this.agent.name}`);
        }

        if (!(this.agent.codeExecutor instanceof BuiltInCodeExecutor)) {
          this.agent.codeExecutor = new BuiltInCodeExecutor();
        }
      }

      const invocationContext = new InvocationContext({
        artifactService: this.artifactService,
        sessionService: this.sessionService,
        memoryService: this.memoryService,
        credentialService: this.credentialService,
        invocationId: newInvocationContextId(),
        agent: this.agent,
        session,
        userContent: newMessage,
        runConfig,
        pluginManager: this.pluginManager,
      });

      // =========================================================================
      // Preprocess plugins on user message
      // =========================================================================
      const pluginUserMessage =
          await this.pluginManager.runOnUserMessageCallback({
            userMessage: newMessage,
            invocationContext,
          });
      if (pluginUserMessage) {
        newMessage = pluginUserMessage as Content;
      }

      // =========================================================================
      // Append user message to session
      // =========================================================================
      if (newMessage) {
        if (!newMessage.parts?.length) {
          throw new Error('No parts in the newMessage.');
        }

        // Directly saves the artifacts (if applicable) in the user message and
        // replaces the artifact data with a file name placeholder.
        // TODO - b/425992518: fix Runner<>>ArtifactService leaky abstraction.
        if (runConfig.saveInputBlobsAsArtifacts) {
          await this.saveArtifacts(
              invocationContext.invocationId, session.userId, session.id,
              newMessage);
        }
        // Append the user message to the session with optional state delta.
        await this.sessionService.appendEvent({
          session,
          event: createEvent({
            invocationId: invocationContext.invocationId,
            author: 'user',
            actions: stateDelta ? createEventActions({stateDelta}) : undefined,
            content: newMessage,
          }),
        });
      }

      // =========================================================================
      // Determine which agent should handle the workflow resumption.
      // =========================================================================
      invocationContext.agent =
          this.determineAgentForResumption(session, this.agent);

      // =========================================================================
      // Run the agent with the plugins (aka hooks to apply in the lifecycle)
      // =========================================================================
      // Step 1: Run the before_run callbacks to see if we should early exit.
      const beforeRunCallbackResponse =
          await this.pluginManager.runBeforeRunCallback({invocationContext});

      if (beforeRunCallbackResponse) {
        const earlyExitEvent = createEvent({
          invocationId: invocationContext.invocationId,
          author: 'model',
          content: beforeRunCallbackResponse,
        });
        // TODO: b/447446338 - In the future, do *not* save live call audio
        // content to session This is a feature in Python ADK
        await this.sessionService.appendEvent({session, event: earlyExitEvent});
        yield earlyExitEvent;

      } else {
        // Step 2: Otherwise continue with normal execution
        for await (const event of invocationContext.agent.runAsync(
            invocationContext)) {
          if (!event.partial) {
            await this.sessionService.appendEvent({session, event});
          }
          // Step 3: Run the on_event callbacks to optionally modify the event.
          const modifiedEvent = await this.pluginManager.runOnEventCallback(
              {invocationContext, event});
          if (modifiedEvent) {
            yield modifiedEvent;
          } else {
            yield event;
          }
        }
      }
      // Step 4: Run the after_run callbacks to optionally modify the context.
      await this.pluginManager.runAfterRunCallback({invocationContext});
    } finally {
      span.end();
    }
  }

  /**
   * Saves artifacts from the message parts and replaces the inline data with
   * a file name placeholder.
   *
   * @param invocationId The current invocation ID.
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @param message The message containing parts to process.
   */
  private async saveArtifacts(
      invocationId: string, userId: string, sessionId: string,
      message: Content): Promise<void> {
    if (!this.artifactService || !message.parts?.length) {
      return;
    }

    for (let i = 0; i < message.parts.length; i++) {
      const part = message.parts[i];
      if (!part.inlineData) {
        continue;
      }
      const fileName = `artifact_${invocationId}_${i}`;
      // TODO - b/425992518: group appname, userId, sessionId as a key.
      await this.artifactService.saveArtifact({
        appName: this.appName,
        userId,
        sessionId,
        filename: fileName,
        artifact: part,
      });
      // TODO - b/425992518: potentially buggy if accidentally exposed to LLM.
      message.parts[i] = createPartFromText(
          `Uploaded file: ${fileName}. It is saved into artifacts`);
    }
  }

  /**
   * Determines the next agent to run to continue the session. This is primarily
   * used for session resumption.
   */
  // TODO - b/425992518: This is where LRO integration should happen.
  // Needs clean up before we can generalize it.
  private determineAgentForResumption(session: Session, rootAgent: BaseAgent):
      BaseAgent {
    // =========================================================================
    // Case 1: If the last event is a function response, this returns the
    // agent that made the original function call.
    // =========================================================================
    const event = findEventByLastFunctionResponseId(session.events);
    if (event && event.author) {
      return rootAgent.findAgent(event.author) || rootAgent;
    }

    // =========================================================================
    // Case 2: Otherwise, find the last agent that emitted a message and is
    // transferable across the agent tree.
    // =========================================================================
    // TODO - b/425992518: Optimize this, not going to work for long sessions.
    // TODO - b/425992518: The behavior is dynamic, needs better documentation.
    for (let i = session.events.length - 1; i >= 0; i--) {
      logger.info('event: ', JSON.stringify(session.events[i]));
      const event = session.events[i];
      if (event.author === 'user' || !event.author) {
        continue;
      }

      if (event.author === rootAgent.name) {
        return rootAgent;
      }

      const agent = rootAgent.findSubAgent(event.author!);
      if (!agent) {
        logger.warn(`Event from an unknown agent: ${event.author}, event id: ${
            event.id}`);
        continue;
      }
      if (this.isRoutableLlmAgent(agent)) {
        return agent;
      }
    }
    // =========================================================================
    // Case 3: default to root agent.
    // =========================================================================
    return rootAgent;
  }

  /**
   * Whether the agent to run can transfer to any other agent in the agent tree.
   *
   * An agent is transferable if:
   *  - It is an instance of `LlmAgent`.
   *  - All its ancestors are also transferable (i.e., they have
   *    `disallowTransferToParent` set to false).
   *
   * @param agentToRun The agent to check for transferability.
   * @returns True if the agent can transfer, False otherwise.
   */
  private isRoutableLlmAgent(agentToRun: BaseAgent): boolean {
    let agent: BaseAgent|undefined = agentToRun;
    while (agent) {
      if (!(agent instanceof LlmAgent)) {
        return false;
      }
      if (agent.disallowTransferToParent) {
        return false;
      }
      agent = agent.parentAgent;
    }
    return true;
  }
  /**
   * Runs the agent in live mode (experimental feature).
   *
   * The `runLive` method yields a stream of `Event` objects, but not all
   * yielded events are saved to the session. Here's a breakdown:
   *
   * **Events Yielded to Callers:**
   * - **Live Model Audio Events with Inline Data:** Events containing raw
   *   audio `Blob` data (`inlineData`).
   * - **Live Model Audio Events with File Data:** Both input and output audio
   *   data are aggregated into a audio file saved into artifacts. The
   *   reference to the file is saved in the event as `fileData`.
   * - **Usage Metadata:** Events containing token usage.
   * - **Transcription Events:** Both partial and non-partial transcription
   *   events are yielded.
   * - **Function Call and Response Events:** Always saved.
   * - **Other Control Events:** Most control events are saved.
   *
   * **Events Saved to the Session:**
   * - **Live Model Audio Events with File Data:** Both input and output audio
   *   data are aggregated into a audio file saved into artifacts. The
   *   reference to the file is saved as event in the `fileData` to session
   *   if RunConfig.saveLiveBlob is True.
   * - **Usage Metadata Events:** Saved to the session.
   * - **Non-Partial Transcription Events:** Non-partial transcription events
   *   are saved.
   * - **Function Call and Response Events:** Always saved.
   * - **Other Control Events:** Most control events are saved.
   *
   * **Events Not Saved to the Session:**
   * - **Live Model Audio Events with Inline Data:** Events containing raw
   *   audio `Blob` data are **not** saved to the session.
   *
   * @param params The parameters for the live invocation.
   * @param params.userId The user ID for the session.
   * @param params.sessionId The session ID for the session.
   * @param params.liveRequestQueue The queue for live requests.
   * @param params.runConfig The run config for the agent.
   * @yields The events generated by the agent.
   *
   * @warning This feature is **experimental** and its API or behavior may
   *   change in future releases.
   */
  async *runLive({
    userId,
    sessionId,
    liveRequestQueue,
    runConfig,
  }: {
    userId: string;
    sessionId: string;
    liveRequestQueue: LiveRequestQueue;
    runConfig?: RunConfig;
  }): AsyncGenerator<Event, void, undefined> {
    runConfig = createRunConfig(runConfig);

    // Some native audio models requires the modality to be set. So we set it to
    // AUDIO by default.
    if (runConfig.responseModalities === undefined) {
      runConfig.responseModalities = [Modality.AUDIO];
    }

    if (!liveRequestQueue) {
      throw new Error('liveRequestQueue is required for runLive.');
    }

    const span = trace.getTracer('gcp.vertex.agent').startSpan('live_invocation');
    try {
      const session = await this.getOrCreateSession({userId, sessionId});

      const invocationContext = this.newInvocationContextForLive(
        session,
        liveRequestQueue,
        runConfig
      );

      // Determine which agent should handle the live session
      invocationContext.agent = this.determineAgentForResumption(
        session,
        this.agent
      );

      // Pre-processing for live streaming tools
      // Inspect the tool's parameters to find if it uses LiveRequestQueue
      invocationContext.activeStreamingTools = {};

      // For shell agents, there is no canonical_tools method so we should skip.
      // Use canonical_tools to get properly wrapped BaseTool instances (fixes #ec6abf40).
      if (
        'canonicalTools' in invocationContext.agent &&
        invocationContext.agent instanceof LlmAgent
      ) {
        const canonicalTools = await (invocationContext.agent as LlmAgent).canonicalTools(
          new ReadonlyContext(invocationContext)
        );
        for (const tool of canonicalTools) {
          // Check if the tool is a FunctionTool with streaming capabilities.
          // FunctionTool.isStreamingFunction checks if the underlying function
          // is an async generator that yields results progressively.
          if (tool instanceof FunctionTool && tool.isStreamingFunction) {
            // Register the streaming tool with its LiveRequestQueue for input stream
            logger.debug(`Register streaming tool with input stream: ${tool.name}`);
            const activeStreamingTool = new ActiveStreamingTool({
              stream: new LiveRequestQueue(),
            });
            invocationContext.activeStreamingTools[tool.name] = activeStreamingTool;
          }
        }
      }

      // Run the before_run callbacks
      const beforeRunCallbackResponse =
        await this.pluginManager.runBeforeRunCallback({invocationContext});

      if (beforeRunCallbackResponse) {
        const earlyExitEvent = createEvent({
          invocationId: invocationContext.invocationId,
          author: 'model',
          content: beforeRunCallbackResponse,
        });
        await this.sessionService.appendEvent({session, event: earlyExitEvent});
        yield earlyExitEvent;
      } else {
        // Run the agent in live mode
        for await (const event of invocationContext.agent.runLive(
          invocationContext
        )) {
          // Determine if we should save this event to the session
          const shouldSaveEvent = this.shouldSaveLiveEvent(event, runConfig);

          if (shouldSaveEvent && !event.partial) {
            await this.sessionService.appendEvent({session, event});
          }

          // Run the on_event callbacks to optionally modify the event
          const modifiedEvent = await this.pluginManager.runOnEventCallback({
            invocationContext,
            event,
          });
          if (modifiedEvent) {
            yield modifiedEvent;
          } else {
            yield event;
          }
        }
      }

      // Run the after_run callbacks
      await this.pluginManager.runAfterRunCallback({invocationContext});
    } finally {
      span.end();
    }
  }

  /**
   * Creates a new invocation context for live mode.
   *
   * @param session The session for the invocation.
   * @param liveRequestQueue The queue for live requests.
   * @param runConfig The run config for the invocation.
   * @returns The invocation context for live mode.
   */
  private newInvocationContextForLive(
    session: Session,
    liveRequestQueue: LiveRequestQueue,
    runConfig: RunConfig
  ): InvocationContext {
    return new InvocationContext({
      artifactService: this.artifactService,
      sessionService: this.sessionService,
      memoryService: this.memoryService,
      credentialService: this.credentialService,
      invocationId: newInvocationContextId(),
      agent: this.agent,
      session,
      runConfig,
      liveRequestQueue,
      activeStreamingTools: {},
      pluginManager: this.pluginManager,
    });
  }

  /**
   * Determines whether an event should be saved to the session in live mode.
   *
   * Events with inline audio data are not saved (they should use file_data
   * for persistence). Partial transcription events are also not saved.
   *
   * @param event The event to check.
   * @param runConfig The run config for the invocation.
   * @returns Whether the event should be saved.
   */
  private shouldSaveLiveEvent(event: Event, runConfig: RunConfig): boolean {
    // Check if this is an audio event with inline data
    if (event.content?.parts) {
      for (const part of event.content.parts) {
        if (part.inlineData?.mimeType?.startsWith('audio/')) {
          // Don't save inline audio data to session
          return false;
        }
      }
    }

    // Save file data events if saveLiveBlob is enabled
    if (event.content?.parts) {
      for (const part of event.content.parts) {
        if (part.fileData && !runConfig.saveLiveBlob) {
          // Don't save file data unless saveLiveBlob is true
          return false;
        }
      }
    }

    // Save all other non-partial events
    return true;
  }

  /**
   * Rewinds the session to before the specified invocation.
   *
   * This operation creates a rewind event that:
   * 1. Reverts session state to what it was before the specified invocation
   * 2. Restores artifacts to their versions at the rewind point
   * 3. Marks the invocation (and all subsequent invocations) as "rewound"
   *
   * After a rewind, the rewound events are still in the event log but will be
   * ignored when constructing LLM context for future requests.
   *
   * @param params The parameters for the rewind operation.
   * @param params.userId The user ID of the session.
   * @param params.sessionId The session ID of the session.
   * @param params.rewindBeforeInvocationId The invocation ID to rewind before.
   * @throws Error if the session is not found or the invocation ID is not found.
   */
  async rewindAsync({
    userId,
    sessionId,
    rewindBeforeInvocationId,
  }: {
    userId: string;
    sessionId: string;
    rewindBeforeInvocationId: string;
  }): Promise<void> {
    const session = await this.getOrCreateSession({userId, sessionId});

    // Find the event index for the rewind point
    let rewindEventIndex = -1;
    for (let i = 0; i < session.events.length; i++) {
      if (session.events[i].invocationId === rewindBeforeInvocationId) {
        rewindEventIndex = i;
        break;
      }
    }

    if (rewindEventIndex === -1) {
      throw new Error(`Invocation ID not found: ${rewindBeforeInvocationId}`);
    }

    // Compute state delta to reverse changes
    const stateDelta = this.computeStateDeltaForRewind(session, rewindEventIndex);

    // Compute artifact delta to reverse changes
    const artifactDelta = await this.computeArtifactDeltaForRewind(
      session,
      rewindEventIndex
    );

    // Create rewind event
    const rewindEvent = createEvent({
      invocationId: newInvocationContextId(),
      author: 'user',
      actions: createEventActions({
        rewindBeforeInvocationId,
        stateDelta,
        artifactDelta,
      }),
    });

    logger.info(`Rewinding session to invocation: ${rewindBeforeInvocationId}`);

    await this.sessionService.appendEvent({session, event: rewindEvent});
  }

  /**
   * Computes the state delta needed to revert session state to the rewind point.
   *
   * This method:
   * 1. Reconstructs the state as it was at the rewind point
   * 2. Compares it to the current state
   * 3. Returns a delta that will restore the state to the rewind point
   *
   * Note: App-level (app:*) and user-level (user:*) state keys are NOT reverted.
   *
   * @param session The session to compute the delta for.
   * @param rewindEventIndex The index of the first event to rewind.
   * @returns The state delta to apply.
   */
  private computeStateDeltaForRewind(
    session: Session,
    rewindEventIndex: number
  ): Record<string, unknown> {
    // Reconstruct state at the rewind point by replaying events up to (but not
    // including) the rewind index
    const stateAtRewindPoint: Record<string, unknown> = {};
    for (let i = 0; i < rewindEventIndex; i++) {
      const event = session.events[i];
      if (event.actions?.stateDelta) {
        for (const [key, value] of Object.entries(event.actions.stateDelta)) {
          // Skip app-level and user-level state
          if (key.startsWith('app:') || key.startsWith('user:')) {
            continue;
          }
          if (value === null || value === undefined) {
            delete stateAtRewindPoint[key];
          } else {
            stateAtRewindPoint[key] = value;
          }
        }
      }
    }

    const currentState = session.state;
    const rewindStateDelta: Record<string, unknown> = {};

    // Add/update keys to match state at rewind point
    for (const [key, valueAtRewind] of Object.entries(stateAtRewindPoint)) {
      if (!(key in currentState) || currentState[key] !== valueAtRewind) {
        rewindStateDelta[key] = valueAtRewind;
      }
    }

    // Set keys to null if they were added after the rewind point
    for (const key of Object.keys(currentState)) {
      // Skip app-level and user-level state
      if (key.startsWith('app:') || key.startsWith('user:')) {
        continue;
      }
      if (!(key in stateAtRewindPoint)) {
        rewindStateDelta[key] = null;
      }
    }

    return rewindStateDelta;
  }

  /**
   * Computes the artifact delta needed to revert artifacts to the rewind point.
   *
   * This method:
   * 1. Tracks artifact versions at the rewind point
   * 2. Compares to current versions
   * 3. Restores artifacts to their previous versions or marks them inaccessible
   *
   * Note: User artifacts (user:*) are NOT reverted.
   *
   * @param session The session to compute the delta for.
   * @param rewindEventIndex The index of the first event to rewind.
   * @returns The artifact delta to apply.
   */
  private async computeArtifactDeltaForRewind(
    session: Session,
    rewindEventIndex: number
  ): Promise<Record<string, number>> {
    if (!this.artifactService) {
      return {};
    }

    // Track artifact versions at the rewind point
    const versionsAtRewindPoint: Record<string, number> = {};
    for (let i = 0; i < rewindEventIndex; i++) {
      const event = session.events[i];
      if (event.actions?.artifactDelta) {
        Object.assign(versionsAtRewindPoint, event.actions.artifactDelta);
      }
    }

    // Track current artifact versions (all events)
    const currentVersions: Record<string, number> = {};
    for (const event of session.events) {
      if (event.actions?.artifactDelta) {
        Object.assign(currentVersions, event.actions.artifactDelta);
      }
    }

    const rewindArtifactDelta: Record<string, number> = {};

    for (const [filename, currentVersion] of Object.entries(currentVersions)) {
      // User artifacts are not restored on rewind
      if (filename.startsWith('user:')) {
        continue;
      }

      const versionAtRewind = versionsAtRewindPoint[filename];

      // Skip if version hasn't changed
      if (versionAtRewind === currentVersion) {
        continue;
      }

      // The new version will be currentVersion + 1
      rewindArtifactDelta[filename] = currentVersion + 1;

      let artifactToSave: {inlineData?: {mimeType: string; data: string}} | {fileData?: {fileUri: string}};

      if (versionAtRewind === undefined) {
        // Artifact did not exist at rewind point - mark it as inaccessible
        // by saving an empty blob
        artifactToSave = {
          inlineData: {
            mimeType: 'application/octet-stream',
            data: '',
          },
        };
      } else {
        // Artifact version changed after rewind point - restore to version at
        // rewind point by creating a file reference to the old version
        const artifactUri = getArtifactUri({
          appName: this.appName,
          userId: session.userId,
          sessionId: session.id,
          filename,
          version: versionAtRewind,
        });
        artifactToSave = {
          fileData: {
            fileUri: artifactUri,
          },
        };
      }

      await this.artifactService.saveArtifact({
        appName: this.appName,
        userId: session.userId,
        sessionId: session.id,
        filename,
        artifact: artifactToSave,
      });
    }

    return rewindArtifactDelta;
  }
}

/**
 * Generates an artifact URI for a specific version of an artifact.
 *
 * @param params The parameters for generating the URI.
 * @returns The artifact URI.
 */
function getArtifactUri({
  appName,
  userId,
  sessionId,
  filename,
  version,
}: {
  appName: string;
  userId: string;
  sessionId: string;
  filename: string;
  version: number;
}): string {
  return `artifact://${appName}/${userId}/${sessionId}/${filename}?version=${version}`;
}

/**
 * It iterates through the events in reverse order, and returns the event
 * containing a function call with a functionCall.id matching the
 * functionResponse.id from the last event in the session.
 */
// TODO - b/425992518: a hack that used event log as transaction log. Fix.
function findEventByLastFunctionResponseId(events: Event[]): Event|null {
  if (!events.length) {
    return null;
  }

  const lastEvent = events[events.length - 1];
  const functionCallId =
      lastEvent.content?.parts?.find((part) => part.functionResponse)
          ?.functionResponse?.id;
  if (!functionCallId) {
    return null;
  }

  // TODO - b/425992518: inefficient search, fix.
  for (let i = events.length - 2; i >= 0; i--) {
    const event = events[i];
    // Looking for the system long running request euc function call.
    const functionCalls = getFunctionCalls(event);
    if (!functionCalls) {
      continue;
    }

    for (const functionCall of functionCalls) {
      if (functionCall.id === functionCallId) {
        return event;
      }
    }
  }
  return null;
}
